<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cosaint na bhFocal — Co. Mayo Noun Game</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0;
      background:#0b0f16;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      display:grid;
      place-items:center;
      min-height:100vh;
      padding:12px;
    }
    .wrap{ width:min(980px,100%); }

    .hud{
      display:flex; gap:8px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-bottom:10px; color:#d7e2ff; font-size:13px;
    }
    .hud .left{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill{
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
      padding:6px 10px;
      border-radius:999px;
      white-space:nowrap;
    }

    canvas{
      width:100%;
      height:auto;
      background: linear-gradient(#070a10, #0b0f16);
      border:1px solid rgba(255,255,255,0.14);
      border-radius:14px;
      box-shadow:0 10px 40px rgba(0,0,0,0.55);
      touch-action:none;
    }

    .controls{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .btn{
      user-select:none;
      -webkit-user-select:none;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.08);
      color:#eaf1ff;
      padding:14px 12px;
      font-size:16px;
      font-weight:650;
      text-align:center;
      box-shadow:0 10px 30px rgba(0,0,0,0.22);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.m { background: rgba(130,190,255,0.18); }
    .btn.f { background: rgba(255,150,220,0.16); }
    .btn.small { font-size:14px; font-weight:600; padding:12px 10px; opacity:1; }

    .btnRow{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }

    .note{ margin-top:8px; opacity:0.9; font-size:12px; }

    .panel{
      margin-top:10px;
      color:#c9d6ff;
      font-size:13px;
      line-height:1.35;
      background:rgba(255,255,255,0.06);
      border:1px solid rgba(255,255,255,0.10);
      border-radius:12px;
      padding:10px 12px;
    }

    @media (min-width: 860px){
      .controls{ grid-template-columns: 1fr 1fr 1fr 1fr; }
      .btnRow{ grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (max-width: 520px){
      .hud{ font-size:12px; }
      .pill{ padding:5px 9px; }
      .btn{ font-size:15px; padding:12px 10px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div class="pill" style="font-size:15px;font-weight:750;">Cosaint na bhFocal</div>
        <div class="pill">Score: <b id="score">0</b></div>
        <div class="pill">Streak: <b id="streak">0</b></div>
        <div class="pill">Lives: <b id="lives">3</b></div>
        <div class="pill">Level: <b id="level">1</b></div>
        <div class="pill">Mode: <b id="mode">Practice</b></div>
      </div>
      <div class="pill">Keys: <b>Z</b> masc · <b>X</b> fem · P pause · R restart · H hints</div>
    </div>

    <!-- Taller playfield to reduce crowding -->
    <canvas id="game" width="960" height="620" aria-label="Cosaint na bhFocal game canvas"></canvas>

    <div class="controls" aria-label="Touch controls">
      <div class="btn m" id="btnM">Masculine (Z)</div>
      <div class="btn f" id="btnF">Feminine (X)</div>
      <div class="btn small" id="btnP">Pause / Resume</div>
      <div class="btn small" id="btnH">Hints: On/Off</div>
    </div>

    <div class="btnRow">
      <div class="btn small" id="btnR">Restart</div>
      <div class="btn small" id="btnLeft">◀ Move</div>
      <div class="btn small" id="btnRight">Move ▶</div>
    </div>

    <div class="note">Tip: drag left/right on the game area to move.</div>

    <div class="panel">
      Mayo-themed nouns fall. Shoot with masculine or feminine. Wrong shot or missed word = lose a life.
    </div>
  </div>

<script>
(() => {
  "use strict";

  // Big-ish word bank (expand freely — doesn’t affect crowding now)
  const NOUNS = [
    // Coast / sea
    { w:"bád", g:"m" }, { w:"iasc", g:"m" }, { w:"cladach", g:"m" }, { w:"calafort", g:"m" },
    { w:"tonn", g:"f" }, { w:"taoide", g:"f" }, { w:"farraige", g:"f" }, { w:"trá", g:"f" },
    { w:"gaoth", g:"f" }, { w:"báisteach", g:"f" }, { w:"stoirm", g:"f" }, { w:"ceo", g:"m" },
    { w:"carraig", g:"f" }, { w:"cloch", g:"f" }, { w:"gainimh", g:"f" }, { w:"salann", g:"m" },
    { w:"bá", g:"f" }, { w:"cuan", g:"m" }, { w:"oileán", g:"m" }, { w:"port", g:"m" },

    // Countryside
    { w:"cnoc", g:"m" }, { w:"sliabh", g:"m" }, { w:"gleann", g:"m" }, { w:"páirc", g:"f" },
    { w:"móin", g:"f" }, { w:"portach", g:"m" }, { w:"talamh", g:"m" }, { w:"féar", g:"m" },
    { w:"abhainn", g:"f" }, { w:"loch", g:"m" }, { w:"tobar", g:"m" }, { w:"droichead", g:"m" },
    { w:"bóthar", g:"m" }, { w:"slí", g:"f" }, { w:"crann", g:"m" }, { w:"coill", g:"f" },
    { w:"bláth", g:"m" }, { w:"éan", g:"m" }, { w:"madra", g:"m" }, { w:"cat", g:"m" },
    { w:"bó", g:"f" }, { w:"lao", g:"m" }, { w:"caora", g:"f" }, { w:"uan", g:"m" },
    { w:"capall", g:"m" }, { w:"asal", g:"m" }, { w:"muc", g:"f" }, { w:"feirm", g:"f" },

    // Home / community
    { w:"teach", g:"m" }, { w:"doras", g:"m" }, { w:"fuinneog", g:"f" }, { w:"seomra", g:"m" },
    { w:"cistin", g:"f" }, { w:"leaba", g:"f" }, { w:"bord", g:"m" }, { w:"cathaoir", g:"f" },
    { w:"eochair", g:"f" }, { w:"balla", g:"m" }, { w:"urlár", g:"m" }, { w:"díon", g:"m" },
    { w:"baile", g:"m" }, { w:"sráid", g:"f" }, { w:"siopa", g:"m" }, { w:"scoil", g:"f" },
    { w:"séipéal", g:"m" }, { w:"cluiche", g:"m" }, { w:"ceol", g:"m" }, { w:"obair", g:"f" },
    { w:"ceist", g:"f" }, { w:"freagra", g:"m" }, { w:"páiste", g:"m" }, { w:"bean", g:"f" }, { w:"fear", g:"m" },
    { w:"aimsir", g:"f" }, { w:"oíche", g:"f" }, { w:"lá", g:"m" }, { w:"seachtain", g:"f" }, { w:"bliain", g:"f" }, { w:"am", g:"m" },
  ];

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha:false });

  const isMobile = matchMedia("(max-width: 560px)").matches;

  function fitCanvas(){
    const cssW = canvas.clientWidth;
    const ratio = window.devicePixelRatio || 1;
    canvas.width  = Math.round(cssW * ratio);
    canvas.height = Math.round((cssW * (620/960)) * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  function W(){ return canvas.clientWidth; }
  function H(){ return canvas.clientHeight; }

  requestAnimationFrame(fitCanvas);
  addEventListener("resize", fitCanvas);

  const scoreEl  = document.getElementById("score");
  const streakEl = document.getElementById("streak");
  const livesEl  = document.getElementById("lives");
  const levelEl  = document.getElementById("level");
  const modeEl   = document.getElementById("mode");

  const state = {
    over:false, paused:false,
    score:0, streak:0, lives:3, level:1,
    time:0, nextSpawn:0,
    invaders:[], shots:[],
    message:{ text:"", until:0 },
    showHints:true,
    seaPhase:0
  };

  const player = { x:0, y:0, w:104, h:18 };

  function updateHUD(){
    scoreEl.textContent = String(state.score);
    streakEl.textContent = String(state.streak);
    livesEl.textContent = String(state.lives);
    levelEl.textContent = String(state.level);
    modeEl.textContent = state.showHints ? "Practice" : "Test";
  }

  function positionPlayer(){
    player.x = W()/2 - player.w/2;
    player.y = H() - 54;
  }

  // ===== Crowd-control knobs =====
  // Keep screen readable.
  const MAX_INVADERS = isMobile ? 6 : 10;

  // Slower fall speed (as requested earlier)
  const FALL_SPEED_MULTIPLIER = 0.33;

  // Bubble sizing (smaller on phones)
  const INVADER_R = isMobile ? 13 : 16;
  const BUBBLE_PAD = isMobile ? 8 : 10;
  const WORD_FONT = isMobile ? 14 : 16;

  // Neutral bubble styling (no gender giveaway)
  const BUBBLE_FILL   = "rgba(235,245,255,0.10)";
  const BUBBLE_STROKE = "rgba(235,245,255,0.26)";

  function invaderSpeed(level){
    const base = 30 + level*5;
    return base * FALL_SPEED_MULTIPLIER;
  }

  // Key fix: reduce spawn rate to match slower fall + cap density
  function baseSpawnInterval(level){
    // bigger number = fewer spawns (less crowding)
    // gentle difficulty curve
    const v = 2.1 - level*0.10;
    return Math.max(1.25, v);
  }

  function shotSpeed(){ return 560; }

  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function showMessage(text, seconds=1.1){
    state.message.text = text;
    state.message.until = state.time + seconds;
  }

  function resetGame(){
    state.over=false; state.paused=false;
    state.score=0; state.streak=0; state.lives=3; state.level=1;
    state.time=0; state.nextSpawn=0.9;
    state.invaders.length=0; state.shots.length=0;
    state.message = { text:"Z = masculine, X = feminine. Tap buttons on phone.", until:2.6 };
    updateHUD();
    positionPlayer();
  }

  // Hints (kept simple)
  function lenite(word){
    if (!word) return word;
    const first = word[0].toLowerCase();
    const lenitable = new Set(["b","c","d","f","g","m","p","s","t"]);
    if (word.length >= 2 && word[1].toLowerCase() === "h") return word;
    if (lenitable.has(first)) return word[0] + "h" + word.slice(1);
    return word;
  }
  const ADJECTIVES = ["mór","beag","fuar","fliuch","garbh","ciúin"];
  function examplePhrase(noun, gender){
    const adj = randChoice(ADJECTIVES);
    const adj2 = (gender === "f") ? lenite(adj) : adj;
    return `${noun} ${adj2}`;
  }

  // Smarter spawning: try to avoid overlaps at spawn time
  function tryPickSpawnX(){
    const padding = 16;
    const minX = padding + (INVADER_R + BUBBLE_PAD);
    const maxX = W() - padding - (INVADER_R + BUBBLE_PAD);
    if (maxX <= minX) return W()/2;

    const minDist = (INVADER_R + BUBBLE_PAD) * 2.2;

    for (let attempt=0; attempt<10; attempt++){
      const x = minX + Math.random()*(maxX - minX);
      let ok = true;
      for (const inv of state.invaders){
        // only check near-top invaders (spawn collision zone)
        if (inv.y > 120) continue;
        const dx = inv.x - x;
        const dy = inv.y - (-24);
        if (dx*dx + dy*dy < minDist*minDist){
          ok = false; break;
        }
      }
      if (ok) return x;
    }
    return minX + Math.random()*(maxX - minX);
  }

  function spawnInvader(){
    const item = randChoice(NOUNS);
    const x = tryPickSpawnX();
    state.invaders.push({
      word:item.w,
      g:item.g,
      x,
      y:-26,
      vy:invaderSpeed(state.level),
      r:INVADER_R,
      hit:false
    });
  }

  function fireShot(gender){
    if (state.over || state.paused) return;
    state.shots.push({
      g:gender,
      x:player.x + player.w/2,
      y:player.y,
      vy:-shotSpeed(),
      r:6
    });
  }

  // Keyboard: Z/X
  addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "p") state.paused = !state.paused;
    if (k === "r") resetGame();
    if (k === "h") { state.showHints = !state.showHints; updateHUD(); }
    if (k === "z") fireShot("m");
    if (k === "x") fireShot("f");
  });

  // Touch
  function bindTap(id, fn){
    document.getElementById(id).addEventListener("pointerdown", (ev)=>{ ev.preventDefault(); fn(); });
  }
  bindTap("btnM", ()=>fireShot("m"));
  bindTap("btnF", ()=>fireShot("f"));
  bindTap("btnP", ()=>{ state.paused = !state.paused; });
  bindTap("btnR", ()=>resetGame());
  bindTap("btnH", ()=>{ state.showHints = !state.showHints; updateHUD(); });

  // Hold-to-move
  let moveLeftHeld=false, moveRightHeld=false;
  function bindHold(id, setHeld){
    const el = document.getElementById(id);
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); setHeld(true); });
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); setHeld(false); });
    el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); setHeld(false); });
    el.addEventListener("pointerleave", (e)=>{ e.preventDefault(); setHeld(false); });
  }
  bindHold("btnLeft", v=>moveLeftHeld=v);
  bindHold("btnRight", v=>moveRightHeld=v);

  // Drag-to-move
  function pointerMove(clientX){
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    player.x = Math.max(10, Math.min(W()-10-player.w, x - player.w/2));
  }
  canvas.addEventListener("pointerdown", (e)=>{ e.preventDefault(); pointerMove(e.clientX); canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener("pointermove", (e)=>{ if (e.buttons) pointerMove(e.clientX); });

  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; }

  function handleHit(inv, shot){
    inv.hit = true;
    const correct = (inv.g === shot.g);

    if (correct){
      state.streak += 1;
      state.score += 10 + Math.min(30, state.streak);
      const gTxt = inv.g === "m" ? "masc" : "fem";
      showMessage(state.showHints
        ? `✓ ${inv.word} (${gTxt}) — e.g. “${examplePhrase(inv.word, inv.g)}”`
        : `✓ ${inv.word} (${gTxt})`,
        state.showHints ? 1.25 : 0.95
      );
    } else {
      state.streak = 0;
      state.score = Math.max(0, state.score - 12);
      state.lives -= 1;
      const gTxt = inv.g === "m" ? "masc" : "fem";
      showMessage(state.showHints
        ? `✗ ${inv.word} is ${gTxt} — e.g. “${examplePhrase(inv.word, inv.g)}”`
        : `✗ ${inv.word} is ${gTxt}`,
        state.showHints ? 1.35 : 1.1
      );
    }

    const newLevel = 1 + Math.floor(state.score / 200);
    if (newLevel !== state.level){
      state.level = newLevel;
      showMessage(`Level ${state.level}!`, 0.9);
    }

    if (state.lives <= 0){
      state.over = true;
      showMessage("Game Over — tap Restart", 999);
    }
    updateHUD();
  }

  // Background (same vibe)
  function drawMayoBackground(dt){
    state.seaPhase += dt * 0.9;
    const horizonY = H() * 0.50;

    ctx.save();

    const skyGrad = ctx.createLinearGradient(0, 0, 0, horizonY);
    skyGrad.addColorStop(0, "rgba(10,16,28,1)");
    skyGrad.addColorStop(1, "rgba(18,28,46,1)");
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W(), horizonY);

    ctx.fillStyle = "rgba(120,160,255,0.08)";
    ctx.fillRect(0, horizonY - 30, W(), 60);

    const seaGrad = ctx.createLinearGradient(0, horizonY, 0, H());
    seaGrad.addColorStop(0, "rgba(10,32,48,1)");
    seaGrad.addColorStop(1, "rgba(6,18,30,1)");
    ctx.fillStyle = seaGrad;
    ctx.fillRect(0, horizonY, W(), H()-horizonY);

    ctx.globalAlpha = 0.22;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(170,210,255,1)";
    for (let i=0; i<9; i++){
      const y = horizonY + 18 + i*28;
      ctx.beginPath();
      const amp = 6 + i*0.6;
      for (let x=0; x<=W(); x+=18){
        const t = state.seaPhase + i*0.6;
        const yy = y + Math.sin((x/85) + t) * amp * 0.35;
        ctx.lineTo(x, yy);
      }
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    ctx.fillStyle = "rgba(8,12,16,0.92)";
    ctx.beginPath();
    ctx.moveTo(0, horizonY + 44);
    ctx.lineTo(W()*0.20, horizonY + 26);
    ctx.lineTo(W()*0.32, horizonY + 38);
    ctx.lineTo(W()*0.44, horizonY + 22);
    ctx.lineTo(W()*0.56, horizonY + 42);
    ctx.lineTo(W()*0.70, horizonY + 28);
    ctx.lineTo(W()*0.84, horizonY + 50);
    ctx.lineTo(W(), horizonY + 34);
    ctx.lineTo(W(), H());
    ctx.lineTo(0, H());
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(14,22,20,0.55)";
    ctx.beginPath();
    ctx.moveTo(0, horizonY);
    ctx.quadraticCurveTo(W()*0.20, horizonY-62, W()*0.38, horizonY-10);
    ctx.quadraticCurveTo(W()*0.56, horizonY+18, W()*0.72, horizonY-26);
    ctx.quadraticCurveTo(W()*0.88, horizonY-74, W(), horizonY-12);
    ctx.lineTo(W(), horizonY);
    ctx.closePath();
    ctx.fill();

    const lx = W()*0.86, ly = horizonY + 28;
    ctx.fillStyle = "rgba(10,10,12,0.95)";
    ctx.beginPath();
    ctx.moveTo(lx-10, ly);
    ctx.lineTo(lx+10, ly);
    ctx.lineTo(lx+6, ly-52);
    ctx.lineTo(lx-6, ly-52);
    ctx.closePath();
    ctx.fill();
    ctx.fillRect(lx-9, ly-58, 18, 8);
    ctx.fillStyle = "rgba(255,245,210,0.12)";
    ctx.beginPath();
    ctx.arc(lx, ly-54, 18, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function roundRect(c, x, y, w, h, r){
    c.beginPath();
    c.moveTo(x+r, y);
    c.arcTo(x+w, y, x+w, y+h, r);
    c.arcTo(x+w, y+h, x, y+h, r);
    c.arcTo(x, y+h, x, y, r);
    c.arcTo(x, y, x+w, y, r);
    c.closePath();
  }

  function drawGround(){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, H()-22);
    ctx.lineTo(W(), H()-22);
    ctx.stroke();
    ctx.restore();
  }

  function drawPlayer(){
    ctx.save();
    ctx.translate(player.x, player.y);

    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.fillRect(0, 0, player.w, player.h);

    const pad = 10;
    const cannonW = (player.w - pad*3)/2;
    const cannonH = 12;

    ctx.fillStyle = "rgba(130,190,255,0.40)";
    ctx.fillRect(pad, -cannonH, cannonW, cannonH);

    ctx.fillStyle = "rgba(255,150,220,0.34)";
    ctx.fillRect(pad*2 + cannonW, -cannonH, cannonW, cannonH);

    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(210,235,255,0.95)";
    ctx.fillText("Z", pad + cannonW/2, -cannonH/2);
    ctx.fillStyle = "rgba(255,220,245,0.95)";
    ctx.fillText("X", pad*2 + cannonW + cannonW/2, -cannonH/2);

    ctx.restore();
  }

  function drawInvader(inv){
    ctx.save();
    ctx.translate(inv.x, inv.y);

    ctx.beginPath();
    ctx.arc(0, 0, inv.r + BUBBLE_PAD, 0, Math.PI*2);
    ctx.fillStyle = BUBBLE_FILL;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = BUBBLE_STROKE;
    ctx.stroke();

    ctx.font = `${WORD_FONT}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(245,248,255,0.95)";
    ctx.fillText(inv.word, 0, 0);

    ctx.restore();
  }

  function drawShot(s){
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.beginPath();
    ctx.arc(0, 0, s.r, 0, Math.PI*2);
    ctx.fillStyle = (s.g === "m") ? "rgba(130,190,255,0.95)" : "rgba(255,150,220,0.95)";
    ctx.fill();
    ctx.restore();
  }

  function drawMessage(){
    if (!state.message.text || state.time > state.message.until) return;

    const text = state.message.text;
    ctx.save();
    ctx.font = isMobile ? "14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"
                        : "16px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const x = W()/2;
    const y = 34;

    const metrics = ctx.measureText(text);
    const padX = 14, padY = 9;
    const boxW = Math.min(W() - 18, metrics.width + padX*2);
    const boxH = 24 + padY*2;

    ctx.fillStyle = "rgba(0,0,0,0.40)";
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    roundRect(ctx, x - boxW/2, y - boxH/2, boxW, boxH, 10);
    ctx.fill();
    ctx.stroke();

    // clip long messages on mobile
    const clipped = (metrics.width + padX*2 > boxW) ? (text.slice(0, 42) + "…") : text;
    ctx.fillStyle = "rgba(235,245,255,0.95)";
    ctx.fillText(clipped, x, y);
    ctx.restore();
  }

  let last = performance.now();

  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    if (player.y === 0) positionPlayer();
    else player.y = H() - 54;

    const moveSpeed = 340;
    if (!state.over && !state.paused){
      if (moveLeftHeld)  player.x -= moveSpeed * dt;
      if (moveRightHeld) player.x += moveSpeed * dt;
      player.x = Math.max(10, Math.min(W()-10-player.w, player.x));
    }

    if (!state.over && !state.paused){
      state.time += dt;

      // Adaptive spawning:
      // - cap invaders
      // - if close to cap, slow spawns further
      const busyFactor = state.invaders.length / MAX_INVADERS; // 0..1
      const extraDelay = (busyFactor > 0.65) ? (busyFactor - 0.65) * 2.2 : 0; // up to ~0.77s extra

      if (state.time >= state.nextSpawn && state.invaders.length < MAX_INVADERS){
        spawnInvader();
        const interval = baseSpawnInterval(state.level) + extraDelay;
        state.nextSpawn = state.time + interval * (0.85 + Math.random()*0.35);
      } else if (state.invaders.length >= MAX_INVADERS) {
        // push next spawn forward while at cap
        state.nextSpawn = Math.max(state.nextSpawn, state.time + 0.35);
      }

      for (const inv of state.invaders) inv.y += inv.vy * dt;
      for (const s of state.shots) s.y += s.vy * dt;

      // Collisions
      for (const inv of state.invaders){
        if (inv.hit) continue;
        for (const s of state.shots){
          if (s.y < -30) continue;
          const rr = (inv.r + BUBBLE_PAD + s.r);
          if (dist2(inv.x, inv.y, s.x, s.y) <= rr*rr){
            s.y = -9999;
            handleHit(inv, s);
            break;
          }
        }
      }

      // Missed bubbles
      for (const inv of state.invaders){
        if (inv.hit) continue;
        if (inv.y >= H() - 30){
          inv.hit = true;
          state.streak = 0;
          state.lives -= 1;
          showMessage(`Missed: ${inv.word}`, 0.95);

          if (state.lives <= 0){
            state.over = true;
            showMessage("Game Over — tap Restart", 999);
          }
          updateHUD();
        }
      }

      // Cleanup
      state.invaders = state.invaders.filter(inv => inv.y < H() + 70 && !inv.hit);
      state.shots = state.shots.filter(s => s.y > -70 && s.y < H() + 70);
    }

    // Draw
    ctx.clearRect(0,0,W(),H());
    drawMayoBackground(dt);
    drawGround();

    for (const inv of state.invaders) drawInvader(inv);
    for (const s of state.shots) drawShot(s);
    drawPlayer();

    if (state.paused && !state.over){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.32)";
      ctx.fillRect(0,0,W(),H());
      ctx.font = "22px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      ctx.fillStyle = "rgba(245,248,255,0.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Paused", W()/2, H()/2);
      ctx.restore();
    }

    if (state.over){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.42)";
      ctx.fillRect(0,0,W(),H());
      ctx.font = "28px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      ctx.fillStyle = "rgba(245,248,255,0.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Game Over", W()/2, H()/2 - 18);
      ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      ctx.fillText("Tap Restart", W()/2, H()/2 + 18);
      ctx.restore();
    }

    drawMessage();
    requestAnimationFrame(tick);
  }

  updateHUD();
  resetGame();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
